#user  nobody;
worker_processes  auto;
worker_rlimit_nofile 65536;

#error_log  logs/error.log;
#error_log  logs/error.log  notice;
#error_log  logs/error.log  info;

#pid        logs/nginx.pid;

events {
    worker_connections  45000;
}

http {
    include       mime.types;
    default_type  application/octet-stream;
    resolver 8.8.8.8;

    log_format  main  '$remote_addr - $remote_user [$time_local] "$request" '
                      '$status $body_bytes_sent "$http_referer" '
                      '"$http_user_agent" "$http_x_forwarded_for" "$proxy_host" "$upstream_addr" '
		              '"$upstream_response_time" "$request_time"';

    access_log  logs/access.log  main;

    sendfile        on;
    #tcp_nopush     on;

    #keepalive_timeout  0;
    keepalive_timeout  65;
    keepalive_requests 10000;

    #gzip  on;
    proxy_cache_path /usr/local/openresty/nginx/cache levels=1:2 keys_zone=gcdn:10m max_size=100g inactive=5m use_temp_path=off;

    server {
        listen       80;
        server_name  localhost;
        proxy_cache gcdn;
        proxy_cache_key $uri$arg_ratio$arg_needwm;
        more_set_headers 'Access-Control-Allow-Origin: *';

        #charset koi8-r;

        #access_log  logs/host.access.log  main;
        #location ~* \.ts$ {
        #    proxy_pass  https://txtest.hls.nimo.tv;
        #    add_header Cache-Control "public, max-age=30";
        #}

        location ~* /(src|live)/((.*)\.ts)$ {
            access_log /usr/local/openresty/nginx/logs/upstream.log main;
            proxy_hide_header Cache-Control;
            add_header Cache-Control "public, max-age=600";
            proxy_intercept_errors on;
            recursive_error_pages on;
            error_page 403 404 500 502 503 504 = @handle_ts_upstream_errors;

            set $upstream '';
            set $url_key '';
            set $arg_symbol $is_args;
            set $origin_error_url '';
            set $origin_retired_ips '';
            set $upstream_ts_is_ip '';
            set $upstream_ts_retry_count '3';

            access_by_lua_block {
                local redis = require "resty.rediscli"
                local red = redis.new({ host = "${REDIS_IP}" })
                local param_id = ngx.var.arg_id
                local param_ratio = ngx.var.arg_ratio
                local param_needwm = ngx.var.arg_needwm
                local key = param_id .. '-' .. (param_ratio or 'ratio-nil') .. '-' .. (param_needwm or 'needwm-nil')
                ngx.var.url_key = key
                local res, err = red:exec(
                    function(red)
                        return red:get(key)
                    end
                )
                if res and res ~= ngx.null then
                    local res_data = require"cjson".decode(res)
                    if type(res_data) == "table" then 
                        ngx.var.upstream_ts_is_ip = 'Y'
                        ngx.var.upstream = res_data[1]:gsub("(%w+%.m3u8)", ngx.var[2])
                        if ngx.var.upstream:find("%?.+=") then
                            ngx.var.arg_symbol = "&"
                        end
                    else
                        ngx.var.upstream_ts_is_ip = 'N'
                        ngx.var.upstream = res_data:gsub("(%w+%.m3u8)",ngx.var[2])
                        if ngx.var.upstream:find("%?.+=") then
                            ngx.var.arg_symbol = "&"
                        end
                        ngx.var.origin_error_url = ngx.var.upstream .. ngx.var.arg_symbol .. ngx.var.args
                    end
                else
                    ngx.exec("@handle_ts_return_origin_errors")
                end
            }
            proxy_pass $upstream$arg_symbol$args;
            proxy_connect_timeout 5s;
            proxy_send_timeout 5s;
            proxy_read_timeout 5s;
        }

        location @handle_ts_upstream_errors {
            access_log /usr/local/openresty/nginx/logs/upstream.log main;
            proxy_hide_header Cache-Control;
            add_header Cache-Control "public, max-age=600";
            proxy_intercept_errors on;
            recursive_error_pages on;
            error_page 403 500 502 503 504 = @handle_ts_upstream_errors;
            access_by_lua_block {
                if ngx.var.upstream_status == "404" then
                    ngx.exec("@handle_ts_return_origin_errors")
                end
                if ngx.var.upstream_ts_is_ip == 'N' then
                    local num = tonumber(ngx.var.upstream_ts_retry_count)
                    if num > 1 then                 
                        ngx.var.upstream_ts_retry_count = num - 1
                    else
                        --the status code obtained here like this : "403 : 403 : 403"
                        --so ngx.var.upstream_status = "403 : 403 : 403"
                        ngx.exec("@handle_ts_return_origin_errors")
                    end
                elseif ngx.var.upstream_ts_is_ip == 'Y' then
                    local redis = require "resty.rediscli"
                    local red = redis.new({ host = "${REDIS_IP}" })
                    local res, err = red:exec(
                            function(red)
                                return red:get(ngx.var.url_key)
                            end
                    )
                    if res and res ~= ngx.null then
                        local res_data = require"cjson".decode(res)
                        if table.getn(res_data[3]) > 0 then
                            ngx.var.upstream = string.gsub(ngx.var.upstream,res_data[2],res_data[3][1])
                            local upstream_webaddress = {}
                            local upstream_backup_ip = res_data[3]         
                            local upstream_changedaddress = string.gsub(res_data[1],res_data[2],res_data[3][1])       
                            table.insert(upstream_webaddress,upstream_changedaddress)
                            table.insert(upstream_webaddress,res_data[3][1])
                            table.remove(upstream_backup_ip,1)
                            table.insert(upstream_webaddress,upstream_backup_ip)
                            local ok, err = red:exec(
                                function(red)
                                    return red:set(ngx.var.url_key, require"cjson".encode(upstream_webaddress), 'EX', ${REDIRECT_CACHE_EXPIRE})
                                end
                            )
                            if not ok then
                                ngx.say("failed to set key: ", err)
                                return
                            end
                        else
                            ngx.var.origin_error_url = ngx.var.upstream .. ngx.var.arg_symbol .. ngx.var.args
                            ngx.var.origin_retired_ips = table.concat(res_data[3], ",")
                            ngx.exec("@handle_ts_return_origin_errors")
                        end
                    else
                        ngx.exec("@handle_ts_return_origin_errors")
                    end
                end
            }
            proxy_pass $upstream$arg_symbol$args;
            proxy_connect_timeout 5s;
            proxy_send_timeout 5s;
            proxy_read_timeout 5s;
        }

        location @handle_ts_return_origin_errors {
            access_log /usr/local/openresty/nginx/logs/upstream.log main;
            content_by_lua_block {
                if ngx.var.upstream_ts_is_ip == "Y" then
                    ngx.header["X-Origin-Error"] = ngx.var.origin_error_url
                    ngx.header["X-Retried-Origin-Ips"] = ngx.var.origin_retired_ips
                    local return_status_code = string.sub(ngx.var.upstream_status, -3)
                    ngx.exit(tonumber(return_status_code))
                elseif ngx.var.upstream_ts_is_ip == "N" then
                    ngx.header["X-Origin-Error"] = ngx.var.origin_error_url
                    local return_status_code = string.sub(ngx.var.upstream_status, -3)
                    ngx.exit(tonumber(return_status_code))
                else
                    ngx.header["X-Origin-Error"] = "Origin cache cleared"
                    ngx.exit(404)
                end
            }
            access_by_lua_block {
                local return_status_code = 1
                if ngx.var.upstream_status then
                    return_status_code = string.sub(ngx.var.upstream_status, -3)
                else
                    return_status_code = 404
                end
                if tonumber(return_status_code) ~= 404 then
                    local redis = require "resty.rediscli"
                    local red = redis.new({ host = "${REDIS_IP}" })
                    local ok, err = red:exec(
                            function(red)
                                return red:del(ngx.var.url_key)
                            end
                    )
                    if not ok then
                        ngx.say("failed to delete key: ", err)
                        return
                    end
                end
            }
        }
        location ~* /([a-zA-Z0-9_]*\.m3u8)$ {
            root   html;
            #    index  index.html index.htm;
            proxy_hide_header Cache-Control;
            add_header Cache-Control "public, max-age=2";
            default_type text/html;
            access_log /usr/local/openresty/nginx/logs/upstream.log main;
            proxy_intercept_errors on;
            recursive_error_pages on;
            error_page 301 302 307 = @handle_m3u8_redirect;
            error_page 403 404 = @handle_m3u8_redirect_4xxerror;
            error_page 500 502 503 = @handle_m3u8_redirect_5xxerror;
            error_page 504 = @handle_m3u8_redirect_timeout;
            set $url_key '';
            set $arg_symbol $is_args;
            set $args_gw '';
            set $request_gw '';
            set $upstream ${API_GATEWAY_URL};
            set $app ${API_GATEWAY_APP};
            set $ext_ip ${EXTERNAL_IP};
            set $request_gw_retry_count '8';
            set $upstream_is_ip '';
            set $upstream_retry_count '3';
            access_by_lua_block {
                local redis = require "resty.rediscli"
                local red = redis.new({ host = "${REDIS_IP}" })
                local param_id = ngx.var.arg_id
                local param_ratio = ngx.var.arg_ratio
                local param_needwm = ngx.var.arg_needwm
                local key = param_id .. '-' .. (param_ratio or 'ratio-nil') .. '-' .. (param_needwm or 'needwm-nil')
                local res, err = red:exec(
                    function(red)
                        return red:get(key)
                    end
                )
                ngx.var.url_key = key
                if res and res ~= ngx.null then
                    ngx.var.request_gw = 'N'
                    local res_data = require"cjson".decode(res)
                    if  type(res_data) == "table" then 
                        ngx.var.upstream_is_ip = 'Y'
                        ngx.var.upstream = res_data[1]:gsub("(%w+%.m3u8)", ngx.var[1])
                        if ngx.var.upstream:find("%?.+=") then
                            ngx.var.arg_symbol = "&"
                        end
                    else
                        ngx.var.upstream_is_ip = 'N'
                        ngx.var.upstream = res_data:gsub("(%w+%.m3u8)",ngx.var[1])
                        if ngx.var.upstream:find("%?.+=") then
                            ngx.var.arg_symbol = "&"
                        end
                    end
                else
                    ngx.var.request_gw = 'Y'
                    ngx.var.args_gw = '&appname=src&app=' .. ngx.var.app .. '&ip=' .. ngx.var.ext_ip
                end
            }
            proxy_pass $upstream$arg_symbol$args$args_gw;
            proxy_connect_timeout 5s;
            proxy_send_timeout 5s;
            proxy_read_timeout 5s;
        }
        location @handle_m3u8_redirect {
            #resolver 8.8.8.8
            access_log /usr/local/openresty/nginx/logs/upstream.log main;
            proxy_hide_header Cache-Control;
            add_header Cache-Control "public, max-age=2";
            proxy_intercept_errors on;
            recursive_error_pages on;
            error_page 301 302 307 = @handle_m3u8_redirect;
            error_page 403 404 = @handle_m3u8_redirect_4xxerror;
            error_page 500 502 503 = @handle_m3u8_redirect_5xxerror;
            error_page 504 = @handle_m3u8_redirect_timeout;
            set $request_gw 'N';
            set $upstream_retry_count '3';
            rewrite_by_lua_block {
                local saved_redirect_location = ngx.var.upstream_http_location
                local saved_redirect_header = ngx.var.upstream_http_bakAddr
                ngx.log(ngx.ERR, "{upstream_http_location:",saved_redirect_location,";","upstream_http_bakAddr:",saved_redirect_header,"}")
                local url_str = ngx.re.match(saved_redirect_location, "(?<=://)[A-Za-z0-9.-]+(?=/)")
                local chunks = {url_str[0]:match("(%d+)%.(%d+)%.(%d+)%.(%d+)")}
                local redis = require "resty.rediscli"
                local red = redis.new({ host = "${REDIS_IP}" })
                if saved_redirect_location:find("%?.+=") then
                    ngx.var.arg_symbol = "&"
                end
                ngx.var.upstream = saved_redirect_location
                if (#chunks == 4) then
                    local hygw_redirects_ipaddr = {}
                    local hygw_redirect_header_ip = {}
                    table.insert(hygw_redirects_ipaddr,saved_redirect_location)
                    table.insert(hygw_redirects_ipaddr,url_str[0])
                    if saved_redirect_header then
                        for ip in string.gmatch(saved_redirect_header, '([^;]+)') do
                            table.insert(hygw_redirect_header_ip,ip)
                        end
                    end
                    table.insert(hygw_redirects_ipaddr,hygw_redirect_header_ip)
                    -- Store bakAddr information, redis value like this:
                    -- ["http:\/\/192.168.1.1\/xxx.xxx.com\/live\/aaaa.m3u8....",
                    --  "192.168.1.1",
                    -- [
                    --  "10.0.0.1",
                    --  "10.0.0.2",
                    --  "10.0.0.3",
                    --  "10.0.0.4"
                    -- ]
                    -- ]
                    local ok, err = red:exec(
                        function(red)
                            return red:set(ngx.var.url_key, require"cjson".encode(hygw_redirects_ipaddr), 'EX', ${REDIRECT_CACHE_EXPIRE})
                        end
                    )               
                    if not ok then
                        ngx.say("failed to set key: ", err)
                        return
                    end
                    ngx.var.upstream_is_ip = 'Y' 
                else
                    -- Store domain name information, redis value like this:
                    -- "http:\/\/xxx.xxx.com\/live\/aaa.m3u8..."
                    local ok, err = red:exec(
                        function(red)
                            return red:set(ngx.var.url_key, require"cjson".encode(saved_redirect_location), 'EX', ${REDIRECT_CACHE_EXPIRE})
                        end
                    )               
                    if not ok then
                        ngx.say("failed to set key: ", err)
                        return
                    end
                    ngx.var.upstream_is_ip = 'N'
                end
            }
            proxy_pass $upstream$arg_symbol$args;
            proxy_connect_timeout 5s;
            proxy_send_timeout 5s;
            proxy_read_timeout 5s;  
        }

        location @handle_m3u8_redirect_5xxerror {
            access_log /usr/local/openresty/nginx/logs/upstream.log main;
            proxy_intercept_errors on;
            recursive_error_pages on;
            error_page 301 302 307 = @handle_m3u8_redirect;
            error_page 403 404 = @handle_m3u8_redirect_4xxerror;
            error_page 500 502 503 504 = @handle_m3u8_redirect_5xxerror;
            # If error is returned from gateway, return 404 to client
            if ($request_gw = 'Y') {
                #add_header request-gw "Y";
                return 404;
            }
            # If error is returned from back to the source, then retry again
            rewrite_by_lua_block {
                local num = tonumber(ngx.var.upstream_retry_count)             
                if num > 1 then 
                    ngx.var.upstream_retry_count = num - 1
                else
                    ngx.exec("@handle_m3u8_redirect_4xxerror")
                end
            }
            proxy_pass $upstream$arg_symbol$args;
            proxy_connect_timeout 5s;
            proxy_send_timeout 5s;
            proxy_read_timeout 5s;  
        }

        location @handle_m3u8_redirect_4xxerror {
            access_log /usr/local/openresty/nginx/logs/upstream.log main;
            proxy_intercept_errors on;
            recursive_error_pages on;
            error_page 301 302 307 = @handle_m3u8_redirect;
            set $upstream ${API_GATEWAY_URL};
            # If error is returned from gateway, return 404 to client
            if ($request_gw = 'Y') {
                #add_header request-gw "Y";
                return 404;
            }
            rewrite_by_lua_block {
                local redis = require "resty.rediscli"
                local red = redis.new({ host = "${REDIS_IP}" })
                -- Delete key to redirect to API gateway
                local ok, err = red:exec(
                        function(red)
                            return red:del(ngx.var.url_key)
                        end
                )               
                if not ok then
                    ngx.say("failed to delete key: ", err)
                    return
                end
                if not ngx.var.args:find("app=") then
                    ngx.var.args_gw = '&appname=src&app=' .. ngx.var.app .. '&ip=' .. ngx.var.ext_ip
                end
            }
            proxy_pass $upstream$is_args$args$args_gw;
            proxy_connect_timeout 5s;
            proxy_send_timeout 5s;
            proxy_read_timeout 5s;  
        }

        location @handle_m3u8_redirect_timeout {
            access_log /usr/local/openresty/nginx/logs/upstream.log main;
            proxy_hide_header Cache-Control;
            add_header Cache-Control "public, max-age=2";
            proxy_intercept_errors on;
            recursive_error_pages on;
            error_page 301 302 307 = @handle_m3u8_redirect;
            error_page 403 404 = @handle_m3u8_redirect_4xxerror;
            error_page 500 502 503 = @handle_m3u8_redirect_5xxerror;
            error_page 504 = @handle_m3u8_redirect_timeout;
            rewrite_by_lua_block {
                -- if request gw timeout ,retry again 
                if ngx.var.request_gw == 'Y' then
                    local num = tonumber(ngx.var.request_gw_retry_count)              
                    if num > 1 then 
                        ngx.var.request_gw_retry_count = num - 1
                    else
                        ngx.exit(404)
                    end
                -- if request doamin name timeout ,retry again
                elseif ngx.var.upstream_is_ip == 'N' then
                    ngx.var.args_gw = ""
                    local num = tonumber(ngx.var.upstream_retry_count)        
                    if num > 1 then 
                        ngx.var.upstream_retry_count = num - 1
                    else
                        ngx.exec("@handle_m3u8_redirect_4xxerror")
                    end
                elseif ngx.var.upstream_is_ip == 'Y' then
                    local redis = require "resty.rediscli"
                    local red = redis.new({ host = "${REDIS_IP}" })
                    local res, err = red:exec(
                            function(red)
                                return red:get(ngx.var.url_key)
                            end
                    )
                    if res and res ~= ngx.null then
                        local res_data = require"cjson".decode(res)
                        if table.getn(res_data[3]) > 0 then
                            ngx.var.upstream = string.gsub(ngx.var.upstream,res_data[2],res_data[3][1])
                            local upstream_webaddress = {}
                            local upstream_backup_ip = res_data[3] 
                            local upstream_changedaddress = string.gsub(res_data[1],res_data[2],res_data[3][1])
                            table.insert(upstream_webaddress,upstream_changedaddress)
                            table.insert(upstream_webaddress,res_data[3][1])
                            table.remove(upstream_backup_ip,1)
                            table.insert(upstream_webaddress,upstream_backup_ip)
                            local ok, err = red:exec(
                                function(red)
                                    return red:set(ngx.var.url_key, require"cjson".encode(upstream_webaddress), 'EX', ${REDIRECT_CACHE_EXPIRE})
                                end
                            )
                            if not ok then
                                ngx.say("failed to set key: ", err)
                                return
                            end
                            ngx.var.args_gw = ""
                        else        
                            ngx.exec("@handle_m3u8_redirect_4xxerror")
                        end
                    else
                        ngx.exec("@handle_m3u8_redirect_4xxerror")
                    end
                end
            }
            proxy_pass $upstream$arg_symbol$args$args_gw;
            proxy_connect_timeout 5s;
            proxy_send_timeout 5s;
            proxy_read_timeout 5s;         
        }
        #error_page  404              /404.html;
        # redirect server error pages to the static page /50x.html
        #
        #error_page   500 502 503 504  /50x.html;
        #location = /50x.html {
        #    root   html;
        #}
        #
    }
}